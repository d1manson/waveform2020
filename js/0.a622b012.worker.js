(function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="8413")})({8413:function(e,t,n){"use strict";n.r(t);const r=Symbol("Comlink.proxy"),o=Symbol("Comlink.endpoint"),a=Symbol("Comlink.releaseProxy"),s=Symbol("Comlink.thrown"),i=e=>"object"===typeof e&&null!==e||"function"===typeof e,l={canHandle:e=>i(e)&&e[r],serialize(e){const{port1:t,port2:n}=new MessageChannel;return g(e,t),[n,[n]]},deserialize(e){return e.start(),m(e)}},c={canHandle:e=>i(e)&&s in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}},u=new Map([["proxy",l],["throw",c]]);function g(e,t=self){t.addEventListener("message",(function n(r){if(!r||!r.data)return;const{id:o,type:a,path:i}=Object.assign({path:[]},r.data),l=(r.data.argumentList||[]).map(x);let c;try{const t=i.slice(0,-1).reduce((e,t)=>e[t],e),n=i.reduce((e,t)=>e[t],e);switch(a){case 0:c=n;break;case 1:t[i.slice(-1)[0]]=x(r.data.value),c=!0;break;case 2:c=n.apply(t,l);break;case 3:{const e=new n(...l);c=w(e)}break;case 4:{const{port1:t,port2:n}=new MessageChannel;g(e,n),c=y(t,[t])}break;case 5:c=void 0;break}}catch(u){c={value:u,[s]:0}}Promise.resolve(c).catch(e=>({value:e,[s]:0})).then(e=>{const[r,s]=S(e);t.postMessage(Object.assign(Object.assign({},r),{id:o}),s),5===a&&(t.removeEventListener("message",n),f(t))})})),t.start&&t.start()}function p(e){return"MessagePort"===e.constructor.name}function f(e){p(e)&&e.close()}function m(e,t){return _(e,[],t)}function d(e){if(e)throw new Error("Proxy has been released and is not useable")}function _(e,t=[],n=function(){}){let r=!1;const s=new Proxy(n,{get(n,o){if(d(r),o===a)return()=>A(e,{type:5,path:t.map(e=>e.toString())}).then(()=>{f(e),r=!0});if("then"===o){if(0===t.length)return{then:()=>s};const n=A(e,{type:0,path:t.map(e=>e.toString())}).then(x);return n.then.bind(n)}return _(e,[...t,o])},set(n,o,a){d(r);const[s,i]=S(a);return A(e,{type:1,path:[...t,o].map(e=>e.toString()),value:s},i).then(x)},apply(n,a,s){d(r);const i=t[t.length-1];if(i===o)return A(e,{type:4}).then(x);if("bind"===i)return _(e,t.slice(0,-1));const[l,c]=b(s);return A(e,{type:2,path:t.map(e=>e.toString()),argumentList:l},c).then(x)},construct(n,o){d(r);const[a,s]=b(o);return A(e,{type:3,path:t.map(e=>e.toString()),argumentList:a},s).then(x)}});return s}function h(e){return Array.prototype.concat.apply([],e)}function b(e){const t=e.map(S);return[t.map(e=>e[0]),h(t.map(e=>e[1]))]}const v=new WeakMap;function y(e,t){return v.set(e,t),e}function w(e){return Object.assign(e,{[r]:!0})}function S(e){for(const[t,n]of u)if(n.canHandle(e)){const[r,o]=n.serialize(e);return[{type:3,name:t,value:r},o]}return[{type:0,value:e},v.get(e)||[]]}function x(e){switch(e.type){case 3:return u.get(e.name).deserialize(e.value);case 0:return e.value}}function A(e,t,n){return new Promise(r=>{const o=E();e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===o&&(e.removeEventListener("message",t),r(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:o},t),n)})}function E(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}var I=n("a90c"),P=n.n(I);const R=4,k=50,T=4,D=2,M=T+k,j={canv:null,gl:null,program:null,locs:{},buffers:{}},F=`#version 300 es\n// see notes on normalizing unsigned/signed data here:\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\nin lowp vec2 a_voltage; // values between [-1, 1]\nin vec2 a_group_xy; // values between [0, 1]\nin lowp float a_group_color; // values between [0, 1]\nflat out lowp float v_group_color;\n\nvoid main() {  \n\n  int channelSegmentId = gl_InstanceID % ${M}; \n  int spikeSegmentId = gl_InstanceID % ${M*R};\n\n  // because of the way we've setup our instanced rendinering, the builtin\n  // glVertexID variable is either 0 or 1, indicating left or right of line segment.\n  int x_within_spike = (spikeSegmentId + gl_VertexID) \n  - (spikeSegmentId/${M}+1) * ${T-D};\n  \n  // the first 5 line segments are nonsense (so we clip them out):\n  // segment 0: previous_byte -- time_byte_1   (to make this work for first wave we ask that the voltage data to be prefixed with a dummy byte)\n  // segment 1: time_byte_1 -- time_byte_2\n  // segment 2: time_byte_2 -- time_byte_3\n  // segment 3: time_byte_3 -- time_byte_4\n  // segment 4: time_byte_4 -- voltage_samp_1\n  // then it's real line segments:\n  // segment 5: voltage_samp_1 -- voltage_samp_2\n  // segment 6: voltage_samp_2 -- voltage_samp_3\n  // ..\n  // segment 52: voltage_samp_48 -- voltage_samp_49\n  // segment 53: voltage_samp_49 -- voltage_samp_50\n  float clip = channelSegmentId >= 5  ? 1.0 : 0.0;\n\n  gl_Position = vec4(\n    -1. + a_group_xy.x*2. \n    + float(x_within_spike)/${M*R}. ,\n    -1. + a_group_xy.y*2. + (a_voltage[gl_VertexID] + 1.)/8.,\n    0.0, // we don't care about depth\n    clip\n    );\n\n    v_group_color = a_group_color ;\n\n}\n`,O="#version 300 es\n\nflat in lowp float v_group_color;\nout lowp vec4 outColor;\n\nvoid main() {\n  outColor = vec4(v_group_color*20.,  sin(v_group_color*100.) ,  sin(v_group_color*150.), 1.);\n}\n";function L(e){j.canv=e,j.gl=j.canv.getContext("webgl2");const t=j.gl;j.program=P.a.createProgramFromSources(t,[F,O],null,null,e=>console.dir(e)),j.gl.viewport(0,0,e.width,e.height),j.gl.useProgram(j.program),j.locs.voltage=j.gl.getAttribLocation(j.program,"a_voltage"),j.buffers.voltage=t.createBuffer(),t.enableVertexAttribArray(j.locs.voltage),j.locs.group_xy=t.getAttribLocation(j.program,"a_group_xy"),j.buffers.group=t.createBuffer(),t.enableVertexAttribArray(j.locs.group_xy),j.locs.group_color=t.getAttribLocation(j.program,"a_group_color"),t.enableVertexAttribArray(j.locs.group_color)}function C(e){const t=e.length,n=new Uint8Array(3*t);for(let r=0;r<t;r++)e[r]>11?(n[3*r+0]=255,n[3*r+1]=255,n[3*r+2]=255):(n[3*r+0]=e[r]%2*128,n[3*r+1]=43*(e[r]>>1),n[3*r+2]=e[r]);return n}function B(e,t){const n=j.gl;n.bindBuffer(n.ARRAY_BUFFER,j.buffers.voltage),n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW),n.vertexAttribPointer(j.locs.voltage,2,n.BYTE,!0,1,0),n.vertexAttribDivisor(j.locs.voltage,1),n.bindBuffer(n.ARRAY_BUFFER,j.buffers.group),n.bufferData(n.ARRAY_BUFFER,C(t),n.STATIC_DRAW),n.vertexAttribPointer(j.locs.group_xy,2,n.UNSIGNED_BYTE,!0,3,0),n.vertexAttribDivisor(j.locs.group_xy,M*R),n.vertexAttribPointer(j.locs.group_color,1,n.UNSIGNED_BYTE,!0,3,2),n.vertexAttribDivisor(j.locs.group_color,M*R),n.drawArraysInstanced(n.LINES,0,2,M*R*t.length)}var $=function(e){return new Promise((t,n)=>{const r=new FileReader;r.onload=()=>t(r.result),r.readAsArrayBuffer(e)})},H=async function(e){const t=await $(e),n=new TextDecoder("utf-8").decode(t.slice(0,1205)),r=n.match(/\r\ndata_start/);if(!r)throw"did not find end of header in tet file.";const o=r.index+r[0].length;return{header:"TODO: parse header",webgl_voltage_data:new Int8Array(t.slice(o-1,-10))}};const N=/n_clusters:\s*(\S*)\s*n_channels:\s*(\S*)\s*n_params:\s*(\S*)\s*times_used_in_Vt:\s*(\S*)\s*(\S*)\s*(\S*)\s*(\S*)/,U=/Exact_cut_for: ((?:[\s\S](?! spikes:))*[\s\S])\s*spikes: ([0-9]*)/,z=/([0-9]+)/g;var V=async function(e){const t=await $(e),n=new TextDecoder("utf-8").decode(t);let r=N.exec(n);const o={};o.n_clusters=parseInt(r[1]),o.n_channels=parseInt(r[2]),o.n_params=parseInt(r[3]),r=U.exec(n),o.exp=r[1],o.n_spikes=parseInt(r[2]),o.data_start=r.index+r[0].length,o.is_clu=!1;const a=n.slice(o.data_start).match(z),s=new Uint16Array(a.length);for(let i=0;i<s.length;i++)s[i]=parseInt(a[i]);return{cut:s,header:o}};const Y=new Map,G={};let W=(e,t)=>null;function X(e){const t=e.name.match(/(.*)(_\d+\.cut|\.set|\.pos|\.\d+)$/);if(!t)return;Y.set(e.name,e);const[n,r,o]=t;let a=G[r];if(a||(a={name:r,date:0,set_file:null,pos_file:null,tetrodes:[]},G[r]=a),".set"===o)a.set_file={name:e.name,short:"~.set"},a.date=e.lastModified;else if(".pos"===o)a.pos_file={name:e.name,short:"~.pos"};else{const t=o.match(/\d+/),n=parseInt(t[0]);let r=a.tetrodes[n];r||(r={tet_file:null,cut_files:[],num:n},a.tetrodes[n]=r),o.match(/cut/)?r.cut_files.push({name:e.name,short:"~.cut"}):r.tet_file={name:e.name,short:"~."+n}}}async function K(e,t){const{webgl_voltage_data:n}=await H(e),{cut:r}=await V(t);B(n,r)}g({addFiles(e){e.forEach(e=>{Y.set(e.name,e),X(e)}),W("update:organised-files",Object.values(G).sort((e,t)=>e.name>t.name?1:-1))},setTriggerFunction(e){W=e},useTileWallCanvas(e){L(e)},render({experiment_name:e,tet_num:t,cut_file_name:n}){const r=G[e].tetrodes[t].tet_file.name,o=Y.get(r),a=Y.get(n);K(o,a)}})},a90c:function(e,t){const n=this;function r(e){return e=e||n,e!==e.top}function o(e){n.console&&(n.console.error?n.console.error(e):n.console.log&&n.console.log(e))}r()||(console.log("%c%s","color:blue;font-weight:bold;","for more about webgl-utils.js see:"),console.log("%c%s","color:blue;font-weight:bold;","http://webgl2fundamentals.org/webgl/lessons/webgl-boilerplate.html"));const a=/ERROR:\s*\d+:(\d+)/gi;function s(e,t=""){const n=[...t.matchAll(a)],r=new Map(n.map((e,r)=>{const o=parseInt(e[1]),a=n[r+1],s=a?a.index:t.length,i=t.substring(e.index,s);return[o-1,i]}));return e.split("\n").map((e,t)=>{const n=r.get(t);return`${t+1}: ${e}${n?"\n\n^^^ "+n:""}`}).join("\n")}function i(e,t,n,r){const a=r||o,i=e.createShader(n);e.shaderSource(i,t),e.compileShader(i);const l=e.getShaderParameter(i,e.COMPILE_STATUS);if(!l){const n=e.getShaderInfoLog(i);return a(`Error compiling shader: ${n}\n${s(t,n)}`),e.deleteShader(i),null}return i}function l(e,t,n,r,a){const i=a||o,l=e.createProgram();t.forEach((function(t){e.attachShader(l,t)})),n&&n.forEach((function(t,n){e.bindAttribLocation(l,r?r[n]:n,t)})),e.linkProgram(l);const c=e.getProgramParameter(l,e.LINK_STATUS);if(!c){const n=e.getProgramInfoLog(l);return i(`Error in program linking: ${n}\n${t.map(t=>{const n=s(e.getShaderSource(t));e.getShaderParameter(t,e.SHADER_TYPE);return n}).join("\n")}`),e.deleteProgram(l),null}return l}function c(e,t,n,r){let o,a="";const s=document.getElementById(t);if(!s)throw"*** Error: unknown script element"+t;if(a=s.text,!n)if("x-shader/x-vertex"===s.type)o=e.VERTEX_SHADER;else if("x-shader/x-fragment"===s.type)o=e.FRAGMENT_SHADER;else if(o!==e.VERTEX_SHADER&&o!==e.FRAGMENT_SHADER)throw"*** Error: unknown shader type";return i(e,a,n||o,r)}const u=["VERTEX_SHADER","FRAGMENT_SHADER"];function g(e,t,n,r,o){const a=[];for(let s=0;s<t.length;++s)a.push(c(e,t[s],e[u[s]],o));return l(e,a,n,r,o)}function p(e,t,n,r,o){const a=[];for(let s=0;s<t.length;++s)a.push(i(e,t[s],e[u[s]],o));return l(e,a,n,r,o)}function f(e,t){t=t||1;const n=e.clientWidth*t|0,r=e.clientHeight*t|0;return(e.width!==n||e.height!==r)&&(e.width=n,e.height=r,!0)}e.exports={createProgram:l,createProgramFromScripts:g,createProgramFromSources:p,resizeCanvasToDisplaySize:f}}});
//# sourceMappingURL=0.a622b012.worker.js.map
{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/comlink/dist/esm/comlink.mjs","webpack:///./src/worker-events.js","webpack:///./src/wave_webgl.js","webpack:///./src/read_as_array_buffer.js","webpack:///./src/parse_tet_file.js","webpack:///./src/parse_cut_file.js","webpack:///./src/main-worker.js","webpack:///./src/webgl-utils.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","proxyMarker","createEndpoint","releaseProxy","throwMarker","isObject","val","proxyTransferHandler","canHandle","obj","port1","port2","MessageChannel","expose","port","start","wrap","throwTransferHandler","serialized","Error","isError","message","stack","assign","transferHandlers","Map","ep","self","addEventListener","callback","ev","data","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","isMessagePort","endpoint","constructor","close","target","createProxy","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","_target","requestResponseMessage","toString","length","_thisArg","rawArgumentList","last","processArguments","myFlat","arr","Array","concat","processed","v","transferCache","WeakMap","transfers","set","handler","serializedValue","serialize","deserialize","msg","generateUUID","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","triggerFn","eventName","payload","setTriggerFunction","triggerNew","trigger","Comlink","nChannelsPerSpike","nVoltageSampsPerChannel","nIrrelevantPrefixBytesPerChannel","nClippedLinesPerChannel","nVoltageLinesPerChannel","nLinesPerChannel","offCanvW","offCanvH","hTimeStep","hGapBetweenChannels","vGapBetweenSpikes","spikeH","spikeW","nColumns","nRowsPerPage","nGroupsPerPage","vertexShaderSource","toFixed","fragmentShaderSource","offCanv","OffscreenCanvas","gl","getContext","program","webglUtils","createProgramFromSources","err","console","dir","viewport","useProgram","locs","voltage","getAttribLocation","group_col_row","group_color","page","getUniformLocation","enableVertexAttribArray","buffers","createBuffer","group","outputCanvs","requestCanvasesFunc","setRequestCanvasesFunction","func","async","ensureOutputCanvsLength","newCanvSpecs","_","ii","width","height","newCanvs","forEach","canv","push","makeGroupColRowData","cut","nSpikes","CUT_DATA","Uint8Array","render","nGroups","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","vertexAttribPointer","BYTE","vertexAttribDivisor","UNSIGNED_BYTE","nPages","ceil","uniform1i","clear","COLOR_BUFFER_BIT","drawArraysInstanced","LINES","min","col","row","clearRect","drawImage","process","file","reject","fr","FileReader","onload","result","readAsArrayBuffer","f","buffer","top_str","TextDecoder","decode","match","data_start","index","header","webgl_voltage_data","Int8Array","regex_cut_a","regex_cut_b","regex_cut_c","fullText","exec","n_clusters","parseInt","n_channels","n_params","exp","n_spikes","is_clu","cut_as_str","Uint16Array","counts","Uint32Array","group_counts","fileFromName","experiments","storeFileWithinExperiments","experimentName","fileExtension","date","set_file","pos_file","tetrodes","short","tetNum","tet","tet_file","cut_files","num","parseTetFile","parseCutFile","renderWaves","addFiles","newFiles","a","b","cut_file_name","tetFileName","tetFile","cutFile","topWindow","this","isInIFrame","w","top","error","log","errorRE","addLineNumbersWithError","src","matches","matchAll","lineNoToErrorMap","ndx","lineNo","next","end","substring","split","line","loadShader","shaderSource","shaderType","opt_errorCallback","errFn","shader","createShader","compileShader","compiled","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","deleteShader","createProgram","shaders","opt_attribs","opt_locations","attachShader","attrib","bindAttribLocation","linkProgram","linked","getProgramParameter","LINK_STATUS","getProgramInfoLog","getShaderSource","SHADER_TYPE","deleteProgram","createShaderFromScript","scriptId","opt_shaderType","shaderScript","document","getElementById","text","VERTEX_SHADER","FRAGMENT_SHADER","defaultShaderType","createProgramFromScripts","shaderScriptIds","shaderSources","resizeCanvasToDisplaySize","canvas","multiplier","clientWidth","clientHeight"],"mappings":"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","file":"js/0.a7d4a7bc.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"8413\");\n","/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case 0 /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case 1 /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case 2 /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case 3 /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case 4 /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case 5 /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === 5 /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: 5 /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: 0 /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: 1 /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: 4 /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 2 /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 3 /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: 3 /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: 0 /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case 3 /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case 0 /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import * as Comlink from \"comlink\";\n\nlet triggerFn = (eventName, payload) => null;\n\n// this is exposed within Comlink.expose({}) in main-worker.js\n// see https://github.com/GoogleChromeLabs/comlink/issues/506#issuecomment-753367898\nexport function setTriggerFunction(triggerNew) {\n  triggerFn = triggerNew;\n}\n\nexport function trigger(eventName, data, transferables) {\n  triggerFn(\n    eventName,\n    transferables ? Comlink.transfer(data, transferables) : data\n  );\n}\n","import webglUtils from \"./webgl-utils\";\nimport { trigger } from \"./worker-events\";\n\nconst nChannelsPerSpike = 4;\nconst nVoltageSampsPerChannel = 50;\nconst nIrrelevantPrefixBytesPerChannel = 4;\n\nconst nClippedLinesPerChannel = 1 + nIrrelevantPrefixBytesPerChannel;\nconst nVoltageLinesPerChannel = nVoltageSampsPerChannel - 1;\n\nconst nLinesPerChannel = nClippedLinesPerChannel + nVoltageLinesPerChannel;\n\n// these are all in the same units, \"pixels\"\nconst offCanvW = 1024;\nconst offCanvH = 1024;\nconst hTimeStep = 2; // horizontal spacing of voltage values\nconst hGapBetweenChannels = 2;\nconst vGapBetweenSpikes = 2;\nconst spikeH = 128;\n\nconst spikeW =\n  (nVoltageLinesPerChannel * hTimeStep + hGapBetweenChannels) *\n  nChannelsPerSpike;\n\nconst nColumns = Math.floor(offCanvW / spikeW);\nconst nRowsPerPage = Math.floor(offCanvH / (spikeH + vGapBetweenSpikes));\nconst nGroupsPerPage = nColumns * nRowsPerPage;\n\nconst vertexShaderSource = `#version 300 es\n// see notes on normalizing unsigned/signed data here:\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\nin lowp vec2 a_voltage; // values between [-1, 1]\nin vec2 a_group_col_row; // values between [0, 1]\nuniform lowp int u_page;\n\nin lowp float a_group_color; // values between [0, 1]\nflat out lowp float v_group_color;\n\nvoid main() {  \n\n  int segment_within_channel = gl_InstanceID % ${nLinesPerChannel}; \n\n  // because of the way we've setup our instanced rendinering, the builtin\n  // gl_VertexID variable is either 0 or 1, indicating left or right of line segment.\n  int t_within_channel = (segment_within_channel - ${nClippedLinesPerChannel} + gl_VertexID);\n  int channel_within_spike = \n    (gl_InstanceID % ${nLinesPerChannel * nChannelsPerSpike})\n    / ${nLinesPerChannel};\n\n  // the first 5 line segments are nonsense (so we clip them out):\n  // segment 0: previous_byte -- time_byte_1   (to make this work for first wave we ask that the voltage data to be prefixed with a dummy byte)\n  // segment 1: time_byte_1 -- time_byte_2\n  // segment 2: time_byte_2 -- time_byte_3\n  // segment 3: time_byte_3 -- time_byte_4\n  // segment 4: time_byte_4 -- voltage_samp_1\n  // then it's real line segments:\n  // segment 5: voltage_samp_1 -- voltage_samp_2\n  // segment 6: voltage_samp_2 -- voltage_samp_3\n  // ..\n  // segment 52: voltage_samp_48 -- voltage_samp_49\n  // segment 53: voltage_samp_49 -- voltage_samp_50\n\n  gl_Position = vec4(\n\n    // x coordinate\n    -1. \n    + a_group_col_row.x * 255. * ${spikeW.toFixed(1)} * 2./${offCanvW.toFixed(\n  1\n)} \n    + float(\n        // this bit is in pixel coordinates\n        channel_within_spike * \n          ${nVoltageLinesPerChannel * hTimeStep + hGapBetweenChannels} + \n        t_within_channel * ${hTimeStep}\n      ) \n      // convert to [-1,+1] gl coords\n      * 2./${offCanvW.toFixed(1)},\n\n    // y coordinate\n    -1. \n     + (a_group_col_row.y *255. - float(u_page) * ${nRowsPerPage.toFixed(1)})\n     * ${(spikeH + vGapBetweenSpikes).toFixed(1)} * 2./${offCanvH.toFixed(1)}\n     + (\n      // this is [0, 2]\n      a_voltage[gl_VertexID] + 1.\n      ) \n      // convert to [-1, +1] gl coords\n      * ${spikeH.toFixed(1)} /${offCanvH.toFixed(1)},\n\n    // depth ..we don't care\n    0.0, // we don't care about depth\n\n    // clip\n    segment_within_channel >= ${nClippedLinesPerChannel}\n     ? 1.0 : 0.0\n\n    );\n\n    v_group_color = a_group_color ;\n\n}\n`;\nconst fragmentShaderSource = `#version 300 es\n\nflat in lowp float v_group_color;\nout lowp vec4 outColor;\n\nvoid main() {\n  outColor = vec4(v_group_color*20.,  sin(v_group_color*100.) ,  sin(v_group_color*150.), 1.);\n}\n`;\n\nconst offCanv = new OffscreenCanvas(offCanvW, offCanvH);\n\nconst gl = offCanv.getContext(\"webgl2\");\n\nconst program = webglUtils.createProgramFromSources(\n  gl,\n  [vertexShaderSource, fragmentShaderSource],\n  null,\n  null,\n  (err) => console.dir(err)\n);\ngl.viewport(0, 0, offCanvW, offCanvH);\ngl.useProgram(program);\n\nconst locs = {\n  voltage: gl.getAttribLocation(program, \"a_voltage\"),\n  group_col_row: gl.getAttribLocation(program, \"a_group_col_row\"),\n  group_color: gl.getAttribLocation(program, \"a_group_color\"),\n  page: gl.getUniformLocation(program, \"u_page\"),\n};\ngl.enableVertexAttribArray(locs.voltage);\ngl.enableVertexAttribArray(locs.group_col_row);\ngl.enableVertexAttribArray(locs.group_color);\n\nconst buffers = {\n  voltage: gl.createBuffer(),\n  group: gl.createBuffer(),\n};\n\nconst outputCanvs = [];\nlet requestCanvasesFunc = null;\nexport function setRequestCanvasesFunction(func) {\n  requestCanvasesFunc = func;\n}\nasync function ensureOutputCanvsLength(n) {\n  if (n <= outputCanvs.length) {\n    return;\n  }\n\n  const newCanvSpecs = Array(n - outputCanvs.length)\n    .fill(null)\n    .map((_, ii) => ({\n      path: `waves.${ii + outputCanvs.length}`,\n      width: spikeW,\n      height: spikeH,\n    }));\n\n  const newCanvs = await requestCanvasesFunc(newCanvSpecs);\n\n  newCanvs.forEach((canv) => outputCanvs.push(canv.getContext(\"2d\")));\n}\n\nfunction makeGroupColRowData(cut) {\n  const nSpikes = cut.length;\n\n  const CUT_DATA = new Uint8Array(nSpikes * 3);\n\n  for (let ii = 0; ii < nSpikes; ii++) {\n    CUT_DATA[ii * 3 + 0] = cut[ii] % nColumns;\n    CUT_DATA[ii * 3 + 1] = (cut[ii] / nColumns) | 0;\n    CUT_DATA[ii * 3 + 2] = cut[ii];\n  }\n\n  return CUT_DATA;\n}\n\nexport async function render(voltage, cut, nGroups) {\n  await ensureOutputCanvsLength(nGroups);\n\n  // Voltage data should consist of nSpikes, where each wave contains:\n  //  four instances of [4-time-bytes 50 voltage bytes].\n  // And there should be a single dummy byte at the start (see\n  // the note within the vertex shader for why this is needed).\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.voltage);\n  gl.bufferData(gl.ARRAY_BUFFER, voltage, gl.STATIC_DRAW);\n\n  // we start with a 1D vector of voltage data.\n  // for simplicitly, lets pretend the data within is:\n  // [0, 1, 2, 3, 4, 5, 6, ...]\n  // this is going to produce a sequence of points as follows:\n  // Point 1. [0,1]\n  // Point 2. [1,2]\n  // Point 3. [2,3]\n  // Point 4. [3,4]\n  // ...\n  //\n  // This is achieved by having two floats per point, but having the\n  // stride only advance 4 bytes, which is one float rather than two\n  gl.vertexAttribPointer(\n    locs.voltage,\n    2, // two elements per point\n    gl.BYTE,\n    true, // normalize\n    1, // only advance 1 bytes (i.e. 1 8-bit int) after each point\n    0\n  );\n  // Now, we take that sequence and say that we will treat each element as\n  // being the per-instance data for an \"instance\", where each instance has\n  // two points. However, the two points are entirely the same, except for the\n  // gl_InstanceID which is 0 for the first point and 1 for the second point.\n  // Thus we get the following data for instances:\n  // Instance 1. [Point1, Point1] i.e. [0: [0,1], 1: [0,1] ]\n  // Instance 2. [Point2, Point2] i.e. [0: [1,2], 1: [1,2] ]\n  // Instance 3. [Point3, Point3] i.e. [0: [2,3], 1: [2,3] ]\n  // By using instances, with 2 points per instance we sneakily end up with\n  // with duplicating each point, once for use on the LHS of a line, and once for\n  // use on the RHS of a line...which is exactly what we need!\n  gl.vertexAttribDivisor(locs.voltage, 1);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.group);\n  gl.bufferData(gl.ARRAY_BUFFER, makeGroupColRowData(cut), gl.STATIC_DRAW);\n  gl.vertexAttribPointer(\n    locs.group_col_row,\n    2, // two elements per point (x,y)\n    gl.UNSIGNED_BYTE,\n    true, // normalize\n    3, // the data is 3 byte elements of x,y,palletId\n    0\n  );\n  gl.vertexAttribDivisor(\n    locs.group_col_row,\n    nLinesPerChannel * nChannelsPerSpike\n  );\n\n  gl.vertexAttribPointer(\n    locs.group_color,\n    1, // one element of palletId\n    gl.UNSIGNED_BYTE,\n    true, // normalize\n    3, // the data is 3 byte elements of x,y,palletId\n    2 // offset 2 bytes (i.e. after x and y bytes)\n  );\n  gl.vertexAttribDivisor(\n    locs.group_color,\n    nLinesPerChannel * nChannelsPerSpike\n  );\n\n  const nPages = Math.ceil(nGroups / nGroupsPerPage);\n\n  for (let page = 0; page < nPages; page++) {\n    gl.uniform1i(locs.page, page);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArraysInstanced(\n      gl.LINES,\n      0,\n      2,\n      nLinesPerChannel * nChannelsPerSpike * cut.length\n    );\n\n    for (\n      let ii = page * nGroupsPerPage;\n      ii < Math.min(outputCanvs.length, (page + 1) * nGroupsPerPage);\n      ii++\n    ) {\n      const col = ii % nColumns,\n        row = ((ii / nColumns) | 0) - page * nRowsPerPage;\n\n      outputCanvs[ii].clearRect(0, 0, spikeW, spikeH);\n      outputCanvs[ii].drawImage(\n        offCanv,\n        col * spikeW,\n        offCanvH - 1 - row * (spikeH + vGapBetweenSpikes) - spikeH,\n        spikeW,\n        spikeH,\n        0,\n        0,\n        spikeW,\n        spikeH\n      );\n    }\n\n    if (process.env.NODE_ENV === \"development\") {\n      const bitmap = offCanv.transferToImageBitmap();\n      trigger(\"debug-offscreen-page-rendered\", bitmap, [bitmap]);\n    }\n  }\n}\n","// wraps the FileReader readAsArrayBuffer api in a promise\n// as suggested https://stackoverflow.com/a/46568146/2399799\nexport default function(file) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = () => resolve(fr.result);\n    fr.readAsArrayBuffer(file);\n  });\n}\n","import readAsArrayBuffer from \"./read_as_array_buffer\";\n\nexport default async function(f) {\n  const buffer = await readAsArrayBuffer(f);\n  const top_str = new TextDecoder(\"utf-8\").decode(buffer.slice(0, 1204 + 1));\n\n  const match = top_str.match(/\\r\\ndata_start/);\n  if (!match) {\n    throw \"did not find end of header in tet file.\";\n  }\n\n  const data_start = match.index + match[0].length;\n  return {\n    header: \"TODO: parse header\",\n    webgl_voltage_data: new Int8Array(\n      buffer.slice(data_start - 1 /* required dummy byte prefix */, -10)\n    ),\n  };\n}\n","import readAsArrayBuffer from \"./read_as_array_buffer\";\n\nconst regex_cut_a = /n_clusters:\\s*(\\S*)\\s*n_channels:\\s*(\\S*)\\s*n_params:\\s*(\\S*)\\s*times_used_in_Vt:\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)/;\nconst regex_cut_b = /Exact_cut_for: ((?:[\\s\\S](?! spikes:))*[\\s\\S])\\s*spikes: ([0-9]*)/;\nconst regex_cut_c = /([0-9]+)/g;\n\nexport default async function(f) {\n  const buffer = await readAsArrayBuffer(f);\n  const fullText = new TextDecoder(\"utf-8\").decode(buffer);\n\n  let match = regex_cut_a.exec(fullText);\n  const header = {};\n  header.n_clusters = parseInt(match[1]);\n  header.n_channels = parseInt(match[2]);\n  header.n_params = parseInt(match[3]);\n\n  match = regex_cut_b.exec(fullText);\n  header.exp = match[1];\n  header.n_spikes = parseInt(match[2]);\n  header.data_start = match.index + match[0].length;\n  header.is_clu = false;\n\n  const cut_as_str = fullText.slice(header.data_start).match(regex_cut_c);\n  const cut = new Uint16Array(cut_as_str.length);\n  const counts = new Uint32Array(header.n_clusters);\n\n  for (let ii = 0; ii < cut.length; ii++) {\n    cut[ii] = parseInt(cut_as_str[ii]);\n    counts[cut[ii]]++;\n  }\n\n  return {\n    cut,\n    header,\n    group_counts: counts,\n  };\n}\n","import * as Comlink from \"comlink\";\nimport {\n  render as renderWaves,\n  setRequestCanvasesFunction,\n} from \"./wave_webgl\";\nimport parseTetFile from \"./parse_tet_file\";\nimport parseCutFile from \"./parse_cut_file\";\nimport { trigger, setTriggerFunction } from \"./worker-events\";\n\nconst fileFromName = new Map();\nconst experiments = {};\n\nfunction storeFileWithinExperiments(f) {\n  const match = f.name.match(/(.*)(_\\d+\\.cut|\\.set|\\.pos|\\.\\d+)$/);\n  if (!match) {\n    return;\n  }\n  fileFromName.set(f.name, f);\n\n  const [_, experimentName, fileExtension] = match;\n  let exp = experiments[experimentName];\n  if (!exp) {\n    exp = {\n      name: experimentName,\n      date: 0,\n      set_file: null,\n      pos_file: null,\n      tetrodes: [],\n    };\n    experiments[experimentName] = exp;\n  }\n\n  if (fileExtension === \".set\") {\n    exp.set_file = { name: f.name, short: \"~.set\" };\n    exp.date = f.lastModified;\n  } else if (fileExtension === \".pos\") {\n    exp.pos_file = { name: f.name, short: \"~.pos\" };\n  } else {\n    const match = fileExtension.match(/\\d+/);\n    const tetNum = parseInt(match[0]);\n    let tet = exp.tetrodes[tetNum];\n    if (!tet) {\n      tet = { tet_file: null, cut_files: [], num: tetNum };\n      exp.tetrodes[tetNum] = tet;\n    }\n    if (fileExtension.match(/cut/)) {\n      tet.cut_files.push({ name: f.name, short: \"~.cut\" });\n    } else {\n      tet.tet_file = { name: f.name, short: `~.${tetNum}` };\n    }\n  }\n}\n\nasync function render(tetFile, cutFile) {\n  const { webgl_voltage_data } = await parseTetFile(tetFile);\n\n  const { cut, group_counts } = await parseCutFile(cutFile);\n  trigger(\"update:cut-counts\", group_counts);\n\n  renderWaves(webgl_voltage_data, cut, group_counts.length);\n}\n\nComlink.expose({\n  addFiles(newFiles) {\n    newFiles.forEach((f) => {\n      fileFromName.set(f.name, f);\n      storeFileWithinExperiments(f);\n    });\n    trigger(\n      \"update:organised-files\",\n      Object.values(experiments).sort((a, b) => (a.name > b.name ? 1 : -1))\n    );\n  },\n  setTriggerFunction,\n  setRequestCanvasesFunction,\n  render({ experiment_name, tet_num, cut_file_name }) {\n    // This is extremely rough, it will need to be substantially rethought when\n    // used for real.\n    const tetFileName =\n      experiments[experiment_name].tetrodes[tet_num].tet_file.name;\n    const tetFile = fileFromName.get(tetFileName);\n    const cutFile = fileFromName.get(cut_file_name);\n    render(tetFile, cutFile);\n  },\n});\n","// copied from https://webgl2fundamentals.org/webgl/resources/webgl-utils.js\n/*\n * Copyright 2012, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst topWindow = this;\n\nfunction isInIFrame(w) {\n  w = w || topWindow;\n  return w !== w.top;\n}\n\nif (!isInIFrame()) {\n  console.log(\n    \"%c%s\",\n    \"color:blue;font-weight:bold;\",\n    \"for more about webgl-utils.js see:\"\n  ); // eslint-disable-line\n  console.log(\n    \"%c%s\",\n    \"color:blue;font-weight:bold;\",\n    \"http://webgl2fundamentals.org/webgl/lessons/webgl-boilerplate.html\"\n  ); // eslint-disable-line\n}\n\n/**\n * Wrapped logging function.\n * @param {string} msg The message to log.\n */\nfunction error(msg) {\n  if (topWindow.console) {\n    if (topWindow.console.error) {\n      topWindow.console.error(msg);\n    } else if (topWindow.console.log) {\n      topWindow.console.log(msg);\n    }\n  }\n}\n\nconst errorRE = /ERROR:\\s*\\d+:(\\d+)/gi;\nfunction addLineNumbersWithError(src, log = \"\") {\n  // Note: Error message formats are not defined by any spec so this may or may not work.\n  const matches = [...log.matchAll(errorRE)];\n  const lineNoToErrorMap = new Map(\n    matches.map((m, ndx) => {\n      const lineNo = parseInt(m[1]);\n      const next = matches[ndx + 1];\n      const end = next ? next.index : log.length;\n      const msg = log.substring(m.index, end);\n      return [lineNo - 1, msg];\n    })\n  );\n  return src\n    .split(\"\\n\")\n    .map((line, lineNo) => {\n      const err = lineNoToErrorMap.get(lineNo);\n      return `${lineNo + 1}: ${line}${err ? `\\n\\n^^^ ${err}` : \"\"}`;\n    })\n    .join(\"\\n\");\n}\n\n/**\n * Error Callback\n * @callback ErrorCallback\n * @param {string} msg error message.\n * @memberOf module:webgl-utils\n */\n\n/**\n * Loads a shader.\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n * @param {string} shaderSource The shader source.\n * @param {number} shaderType The type of shader.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n * @return {WebGLShader} The created shader.\n */\nfunction loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n  const errFn = opt_errorCallback || error;\n  // Create the shader object\n  const shader = gl.createShader(shaderType);\n\n  // Load the shader source\n  gl.shaderSource(shader, shaderSource);\n\n  // Compile the shader\n  gl.compileShader(shader);\n\n  // Check the compile status\n  const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!compiled) {\n    // Something went wrong during compilation; get the error\n    const lastError = gl.getShaderInfoLog(shader);\n    errFn(\n      `Error compiling shader: ${lastError}\\n${addLineNumbersWithError(\n        shaderSource,\n        lastError\n      )}`\n    );\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\n/**\n * Creates a program, attaches shaders, binds attrib locations, links the\n * program and calls useProgram.\n * @param {WebGLShader[]} shaders The shaders to attach\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n *        on error. If you want something else pass an callback. It's passed an error message.\n * @memberOf module:webgl-utils\n */\nfunction createProgram(\n  gl,\n  shaders,\n  opt_attribs,\n  opt_locations,\n  opt_errorCallback\n) {\n  const errFn = opt_errorCallback || error;\n  const program = gl.createProgram();\n  shaders.forEach(function(shader) {\n    gl.attachShader(program, shader);\n  });\n  if (opt_attribs) {\n    opt_attribs.forEach(function(attrib, ndx) {\n      gl.bindAttribLocation(\n        program,\n        opt_locations ? opt_locations[ndx] : ndx,\n        attrib\n      );\n    });\n  }\n  gl.linkProgram(program);\n\n  // Check the link status\n  const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!linked) {\n    // something went wrong with the link\n    const lastError = gl.getProgramInfoLog(program);\n    errFn(\n      `Error in program linking: ${lastError}\\n${shaders\n        .map((shader) => {\n          const src = addLineNumbersWithError(gl.getShaderSource(shader));\n          const type = gl.getShaderParameter(shader, gl.SHADER_TYPE);\n          return src;\n        })\n        .join(\"\\n\")}`\n    );\n\n    gl.deleteProgram(program);\n    return null;\n  }\n  return program;\n}\n\n/**\n * Loads a shader from a script tag.\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n * @param {string} scriptId The id of the script tag.\n * @param {number} opt_shaderType The type of shader. If not passed in it will\n *     be derived from the type of the script tag.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n * @return {WebGLShader} The created shader.\n */\nfunction createShaderFromScript(\n  gl,\n  scriptId,\n  opt_shaderType,\n  opt_errorCallback\n) {\n  let shaderSource = \"\";\n  let shaderType;\n  const shaderScript = document.getElementById(scriptId);\n  if (!shaderScript) {\n    throw \"*** Error: unknown script element\" + scriptId;\n  }\n  shaderSource = shaderScript.text;\n\n  if (!opt_shaderType) {\n    if (shaderScript.type === \"x-shader/x-vertex\") {\n      shaderType = gl.VERTEX_SHADER;\n    } else if (shaderScript.type === \"x-shader/x-fragment\") {\n      shaderType = gl.FRAGMENT_SHADER;\n    } else if (\n      shaderType !== gl.VERTEX_SHADER &&\n      shaderType !== gl.FRAGMENT_SHADER\n    ) {\n      throw \"*** Error: unknown shader type\";\n    }\n  }\n\n  return loadShader(\n    gl,\n    shaderSource,\n    opt_shaderType ? opt_shaderType : shaderType,\n    opt_errorCallback\n  );\n}\n\nconst defaultShaderType = [\"VERTEX_SHADER\", \"FRAGMENT_SHADER\"];\n\n/**\n * Creates a program from 2 script tags.\n *\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n *        to use.\n * @param {string[]} shaderScriptIds Array of ids of the script\n *        tags for the shaders. The first is assumed to be the\n *        vertex shader, the second the fragment shader.\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n *        on error. If you want something else pass an callback. It's passed an error message.\n * @return {WebGLProgram} The created program.\n * @memberOf module:webgl-utils\n */\nfunction createProgramFromScripts(\n  gl,\n  shaderScriptIds,\n  opt_attribs,\n  opt_locations,\n  opt_errorCallback\n) {\n  const shaders = [];\n  for (let ii = 0; ii < shaderScriptIds.length; ++ii) {\n    shaders.push(\n      createShaderFromScript(\n        gl,\n        shaderScriptIds[ii],\n        gl[defaultShaderType[ii]],\n        opt_errorCallback\n      )\n    );\n  }\n  return createProgram(\n    gl,\n    shaders,\n    opt_attribs,\n    opt_locations,\n    opt_errorCallback\n  );\n}\n\n/**\n * Creates a program from 2 sources.\n *\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n *        to use.\n * @param {string[]} shaderSourcess Array of sources for the\n *        shaders. The first is assumed to be the vertex shader,\n *        the second the fragment shader.\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n *        on error. If you want something else pass an callback. It's passed an error message.\n * @return {WebGLProgram} The created program.\n * @memberOf module:webgl-utils\n */\nfunction createProgramFromSources(\n  gl,\n  shaderSources,\n  opt_attribs,\n  opt_locations,\n  opt_errorCallback\n) {\n  const shaders = [];\n  for (let ii = 0; ii < shaderSources.length; ++ii) {\n    shaders.push(\n      loadShader(\n        gl,\n        shaderSources[ii],\n        gl[defaultShaderType[ii]],\n        opt_errorCallback\n      )\n    );\n  }\n  return createProgram(\n    gl,\n    shaders,\n    opt_attribs,\n    opt_locations,\n    opt_errorCallback\n  );\n}\n\n/**\n * Resize a canvas to match the size its displayed.\n * @param {HTMLCanvasElement} canvas The canvas to resize.\n * @param {number} [multiplier] amount to multiply by.\n *    Pass in window.devicePixelRatio for native pixels.\n * @return {boolean} true if the canvas was resized.\n * @memberOf module:webgl-utils\n */\nfunction resizeCanvasToDisplaySize(canvas, multiplier) {\n  multiplier = multiplier || 1;\n  const width = (canvas.clientWidth * multiplier) | 0;\n  const height = (canvas.clientHeight * multiplier) | 0;\n  if (canvas.width !== width || canvas.height !== height) {\n    canvas.width = width;\n    canvas.height = height;\n    return true;\n  }\n  return false;\n}\n\nmodule.exports = {\n  createProgram: createProgram,\n  createProgramFromScripts: createProgramFromScripts,\n  createProgramFromSources: createProgramFromSources,\n  resizeCanvasToDisplaySize: resizeCanvasToDisplaySize,\n};\n"],"sourceRoot":""}